# 값

값(value) 은 표현식(expression) 이 평가(evaluate) 되어 생성된 결과

- 평가(evaluate) : 식을 해석해서 `값을 생성하거나 참조하는 것`

# 리터럴

리터럴(literal) 은 사람이 이해할 수 있는 문자 혹은 약속된 기호를 사용해 값을 생성하는 표기법(notation) 자바스크립트 엔진은 코드가 실행되는 시점인 `런타임(runtime)` 에 리터럴을 평가해 값을 생성한다.

# 표현식

표현식(expression) 은 값으로 평가될 수 있는 문(statement)

- 표현식이 평가되면 새로운 값을 생성하거나 기존 값을 참조한다.
- 값으로 평가될 수 있는 문(statement)는 모두 표현식이다.

```jsx
var score = 30;
/*
- 30은 숫자 리터럴
- 숫자 리터럴 30은 자바스크립트 엔진에 의해 런타임 시 평가되어 숫자 30을 생성하므로 리터럴은 그 자체로 표현식
*/

var score = 10 + 20;
/*
- 10 + 20 은 리터럴과 연산자로 이뤄져있다.
- 10 + 20은 자바스크립트 엔진에 의해 평가되어 숫자 값 30을 생성하므로 표현식이다.
*/

score;
/*
- 변수 식별자를 참조하면 변수 값으로 평가된다.
- 식별자 참조는 값을 생성하지는 않지만 값으로 평가되므로 표현식이다.
*/
```

# 문

문(statement) 은 프로그램을 구성하는 기본 단위이자 최소 실행 단위

- 문은 `명령문` 이라고도 부른다.
- `문의 집합` 으로 이뤄진 것이 `프로그램`
  - 문을 작성 & 순서에 맞게 나열하는 것이 `프로그래밍`
- 문은 여러 토큰으로 구성
  - `토큰(token)` : 문법적인 의미를 가지며, `문법적으로 더 이상 나눌 수 없는` 코드의 기본 요소
  - 예를 들어, `키워드`, `식별자`, `리터럴`, `세미콜론(;)`, `마침표(.)` 등

💡 **문(statement) 와 표현식 (expression)은 다르다.**

```
- 문과 표현식을 구별하고 해석할 수 있다면 자바스크립트 엔진의 입장에서 코드를 읽을 수 있고 실행 결과를 예측하는 데 도움이 된다.
- 이는 버그를 줄이고 코드의 품질을 높이는 방향이다.
```

- `표현식인 문` = 값으로 평가될 수 있는 문
- `표현식이 아닌 문` = 값으로 평가될 수 없는 문

문과 표현식이 아닌 문을 구별하는 가장 간단하고 명료한 방법은 `변수에 할당해보는 것` 이다.

```jsx
var x; // 변수 선언문 = "값"으로 평가될 수 없으므로 표현식 X

x = 1 + 2; // 1 + 2를 엔진이 런타임 시점에서 숫자 값 3을 생성하므로 표현식이면서 또한 완전한 문

var test = var x;  // 변수할당 불가능 -> SyntaxError
var test = x = 100; // 변수할당 가능
```

💡 **완료 값 (completion value)**

```
- 크롬 개발자 도구에서 "표현식이 아닌 문"을 실행하면 undefined 를 출력한다. 이를 "완료 값"이라 한다.
- 완료 값은 표현식의 평가 결과가 아니므로, 다른 값과 같이 변수에 할당할 수 없고 참조도 할 수 없다.
```

# 세미콜론

세미콜론(;) 은 문의 종료를 의미한다.

- 자바스크립트 엔진은 세미콜론으로 문이 종료한 위치를 파악하고 순차적으로 하나씩 문을 실행한다. 따라서 문을 끝날 때는 세미콜론을 붙이는 것이 일반적이다.
- 단, 괄호로 묶은 코드 블록({ ... }) 뒤에는 세미콜론을 붙이지 않는다.
  - `if문`, `for 문`, `함수` 등
  - 언제나 문의 종료를 의미하는 `자체 종결성(self closing)` 을 갖기 때문이다.
- 세미콜론은 옵션이다.
  - 자바스크립트 엔진이 소스코드를 해석할 때 문의 끝이라고 예측되는 지점에 세미콜론을 암묵적,자동으로 붙여주기 때문 `세미콜론 자동 삽입 기능(ASI, Automatic Semicolon Insertion)`
  - 하지만, 개발자의 실수로 ASI의 동작을 제대로 예측하지 못해, 프로그램에 문제가 발생할 수 있으니 문장에 끝에 세미콜론 붙이는 것을 습관 화 하는 것이 좋다.
